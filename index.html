<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Functional Style in Java 8</title>

		<meta name="description" content="Introduction to Functional Style programming and Java 8 features to support it">
		<meta name="author" content="Debbie Roycroft">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="reveal.js/css/reveal.css">
		<link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
        <link rel="stylesheet" href="css/textcolours.css">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'reveal.js/css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="reveal.js/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
			<!-- Slide 1: -->
				<section>
					<h1>Java 8 and Functional Style Programming</h1>
					<p>
						<small>Debbie Roycroft 
                                                <a href="http://twitter.com/DebbieRoycroft">@DebbieRoycroft</a></small></p>
						<h4>Manchester Java Community</h3>
                     <p>           <small><a href="http://twitter.com/mcrjava">@mcrjava</a></small> </p>
                     <p>           <small><a href="http://www.meetup.com/ManchesterUK-Java-Community/"> meetup group</a></small> </p>
					<p> <small><a href="https://www.linkedin.com/groups/Manchester-Java-Community-8270682/about">linkedin group</a></small></p>
				</section>
			<!-- Slide 2: -->
				<section>
					<h2>Functional style programming</h2>
					<ul>
					<li class="fragment fade-in">What is it</li>
					<li class="fragment fade-in">Why is it advocated</li>
					<li class="fragment fade-in">How would you move from imperative to functional/declarative</li>
					<li class="fragment fade-in">Try it out</li>
					</ul>
				</section>
			<!-- Slide 3: -->
				<section>
					<section>
						<h2>Functional/Declarative Style vs Imperative Style</h2>
						<ul>
						<li class="fragment fade-in">What rather than how</li>
						<aside class="notes">Up to now we've had to program Java in an imperative style- the code is written to 
								tell the compiler exactly how to do something, whereas the declarative style can be seen as telling the 
								system 'what' you want done, and allowing it more freedom to optimize.
						</aside>
						</ul>
					</section>
					<section>
						<p>Imperative style</p>
						<pre><code data-trim>
for( String word : words){
    if (word.equals(wordToMatch)){
        ++count;
    }
}
						</pre></code>
						<span class="fragment fade-in">
						<p>Functional style</p>
						<pre><code data-trim>
count = words.stream()
             .filter((word)-&gt; {return word.equals(wordToMatch);})
             .count();
						</code></pre>
						</span>
					</section>
				</section>
				<!--Slide 4-->
				<section>
					<section>
						<h2>Functional/Declarative Style vs Imperative Style</h2>
						<ul>
						<li>What rather than how</li>
						<li class="fragment fade-in">Pass functions as well as objects </li>
						</ul>
						<aside class="notes"> functions and objects treated the same - first-class functions</aside>
					</section>
					<section>
						<p>Lambdas are behaviour (functions) passed like objects in older java</p>
						<pre><code data-trim>
boolean allEven = numbers.stream()
                         .allMatch(num-&gt;{ return num % 2 == 0;});						
						</code></pre>
						<span class="fragment fade-in">
						<pre><code data-trim>
public Predicate&lt;Integer&gt; getTest(){
    return ((Integer input)-&gt; { return input % 2 != 0; });
}
						</code></pre></span>
						<span class="fragment fade-in">
						<pre><code data-trim>
Predicate&lt;Integer&gt; predicate = 
               ((Integer input)-&gt; { return input % 2 == 0; });
boolean allEven = numbers.stream().allMatch(predicate);
						</code></pre></span>
					</section>
				</section>
				<!--Slide 5-->
				<section>
					<section>
						<h2>Functional/Declarative Style vs Imperative Style</h2>
						<ul>
						<li>What rather than how</li>
						<li>Pass functions as well as objects </li>
						<li class="fragment fade-in">Functional composition</li>
						</ul>
					</section>
					<section>
							<p>Complex functions composed of smaller simpler functions</p>
							<pre><code data-trim>
List&lt;Book&gt; sortedBooks = books.stream()
    .sorted(Comparator.comparing(Book::getAuthor)
                      .thenComparing(Book::getTitle))
    .collect(Collectors.toList());
							</pre></code>
					</section>
				</section>
				<!--Slide 6-->
				<section>
					<section>
						<h2>Functional/Declarative Style vs Imperative Style</h2>
						<ul>
						<li>What rather than how</li>
						<li>Pass functions as well as objects </li>
						<li>Functional composition</li>
						<li class="fragment fade-in">Transform rather than mutate</li>
						</ul>
					</section>
					<section>
							<p>Mutating the supplied collection</p>
							<pre><code data-trim>
Collections.sort(titles);
							</pre></code>
							<span class="fragment fade-in">
							<p>Transforming the supplied collection</p>
							<pre><code data-trim>	
List&lt;String&gt; sortedList = titles.stream()
                                .sorted()
                                .collect(Collectors.toList());
							</pre></code>
							</span>
					</section>
				</section>
				<!--Slide 7-->
				<section>
					<section>
						<h2>Functional/Declarative Style vs Imperative Style</h2>
						<ul>
						<li>What rather than how</li>
						<li>Pass functions as well as objects </li>
						<li>Functional composition</li>
						<li>Transform rather than mutate</li>
						<li class="fragment fade-in">Pure functions rather than those with side-effects</li>
						</ul>
					</section>
				</section>
				<!--Slide 8-->
				<section>
					<h2>Why do this?</h2>
					<ul>
					<li class="fragment fade-in">Makes code more concise
						<aside class="notes">less 'boiler plate'</aside>
					</li>
					<li class="fragment fade-in">Makes intention of code clearer
						<aside class="notes"> more readable? (once you get used to the new syntax)</aside>
					</li>
					<li class="fragment fade-in">Makes it easier to make use of parallelism 
						<aside class="notes">
						pure functions more likely to be thread safe, streams API parallel streams are easy to add
						</aside>
					</li>
					<li class="fragment fade-in">More efficient
						<aside class="notes"> possibly? Compiler *may* be able to optimize code in declarative style</aside>
					</li>
					<li class="fragment fade-in">Less error prone
						<aside class="notes">maybe? - esp for pure functions 
						(less side-effects means less 'odd' bugs caused by code executing in an unexpected order)
						</aside>
					</li>
					</ul>
				</section>
				<!--Slide 9-->
				<section>
					<h2>Functional programming in Java 8</h2>
					<ul>
					<li class="fragment fade-in">Functional interfaces
						<aside class="notes">A functional interface is an interface with a single abstract method.
						</aside>
					</li>
					<li class="fragment fade-in">Lambdas
						<aside class="notes">Lambdas allow us to store or pass (or return) a function where we might previously 
						have only expected to be able to use an object. Lambdas can be used anywhere where a functional interface 
						is expected.
						</aside>
					</li>
					
					<li class="fragment fade-in">Default methods
						<aside class="notes">Interfaces provided in java.util.function such as Function, Predicate, Consumer define default methods allowing functions to be chained together (functional composition) e.g. Function::andThen
							Streams API provides methods for external iteration and functional composition for processing collections</aside>
					</li>
					</ul>
				</section>
				<!--Slide 10-->
				<section>
					<section>
						<h2>How to do it?</h2>
						<ul>
						<li class="fragment fade-in">Lambdas to replace objects encapsulating behaviour</li>
					</ul>
					</section>
					<section>
					<aside class="notes">Functional interfaces have been added to many of the core apis.  
						Lambdas to replace anonymous functions - 
						removes excessive boilerplate code and makes the intention of the code clearer.  
						IDE will suggest this change for you.
						</aside>
					<p>Creating an anonymous class just to implement a single method like this:</p>
					<pre><code data-trim>
JButton okButton = new JButton();
okButton.addActionListener( new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent event) {
            submitForm();
        }});
					</pre></code>
					<span class="fragment fade-in">
					<p>Can now be done with a lambda like this:</p>
					<pre><code data-trim>
JButton okButton = new JButton();
okButton.addActionListener( event -&gt; submitForm());
					</pre></code>
					</span>
					</section>
				</section>
				<!--Slide 11-->
				<section>
					<section>
						<h2>How to do it?</h2>
						<ul>
						<li>Lambdas to replace objects encapsulating behaviour</li>
						<li class="fragment fade-in">Use functional interfaces to pass behaviour</li>
					</ul>
					</section>

					<section>
					<aside class="notes">
					We can make use of predefined functional interfaces like predicate, consumer and supplier when we 
					define our own methods to allow us to pass behaviour in our own code e g. Delayed conditional execution patterns- we can use functional interfaces like Supplier to make sure we only call expensive functions when we really need to.
					Example if we have a message writer, but the process of producing the message itself is expensive:
					</aside>
					<pre><code data-trim>
public void writeMessage(String message){
    if (messageRequired){
        doWrite(message);
    }
}	
					
messageWriter.writeMessage(generateMessage());
					</pre></code>
					<p>Replaced with</p>
					<pre><code data-trim>
public void writeMessage(Supplier&lt;String&gt; messageSupplier){
    if (messageRequired){
        doWrite(messageSupplier.get());
    }
}

messageWriter.writeMessage(() -&gt; generateMessage());</pre></code>
					</section>
				</section>
				<!--Slide 12-->
				<section>
					<section>
						<h2>How to do it?</h2>
						<ul>
						<li>Lambdas to replace objects encapsulating behaviour</li>
						<li>Use functional interfaces to pass behaviour</li>
						<li class="fragment fade-in">Streams to replace loops</li>
						</ul>
					</section>
					<section>
					<p>As well as iterating over collections, we can use streams to replace code like this</p>
					<pre><code data-trim>
List&lt;String&gt; result = new ArrayList&lt;&gt;();
for( int i=0; i&lt; 10; ++i){
    if (i % 3 == 0 ) result.add("Fizz");
    else if (i % 5 == 0 ) result.add("Buzz");
    else result.add(Integer.toString(i));
}
		</pre></code>
		<span class="fragment fade-in">
		<p>with code like this</p>
		<pre><code data-trim>
IntFunction&lt;String&gt; fizzBuzz = (i)-&gt; {
    if (i % 3 == 0 ) return "Fizz";
    else if (i % 5 == 0 ) return "Buzz";
    else return Integer.toString(i); 
};
List&lt;String&gt; result = IntStream.range(0, 10)
                                      .mapToObj(fizzBuzz)
                                      .collect(Collectors.toList());
		
		</pre></code>
		</span>
					</section>
				</section>
				<!--Slide 13-->
				<section>
					<section>
						<h2>How to do it?</h2>
						<ul>
						<li>Lambdas to replace objects encapsulating behaviour</li>
						<li>Use functional interfaces to pass behaviour</li>
						<li>Streams to replace loops</li>
						<li class="fragment fade-in">Reduce mutability 
							<aside class="notes">Implement functions to have no side effects and not depend on external state (pure functions) - unlike purely functional languages, Java won't force this on us.
							</aside>
						</li>
						</ul>
					</section>
					<section>
					<p>Counters or state variables for loops</p>
					<pre><code data-trim>
public String find(List&lt;String&gt; stringsToSearch, String stringToFind){
    String found= null;
    for( String string : stringsToSearch ){
        if ( string.equals(stringToFind)){
            found = string;
            break;
        }
    }
    return found;
}
					</pre></code>
					<span class="fragment fade-in">
					<p>Replaced with result of function</p>
					<pre><code data-trim>
public String find(List&lt;String&gt; stringsToSearch, String stringToFind){
    return stringsToSearch.stream()
                          .filter(string-&gt;string.equals(stringToFind))
                          .findFirst()
                          .orElse(null);
}
					</pre></code></span>
					</section>
				</section>
				<section>
				<h2>Further reading and resources</h2>
				<ul>
				<li>Java 8 in Action: Lambdas, streams, and functional-style programming by Raoul-Gabriel Urma, Mario Fusco, and Alan Mycroft</li>
				<li>Venkat Subramaniam on Parleys.com</li>
				<ul><li>Transforming Code to Java 8</li><li>Thinking in Functional Style</li></ul>
				<li>Simon Ritter's MOOC Training in Lambdas and Streams</li>
				<ul><li><a href="https://www.youtube.com/playlist?list=PLMod1hYiIvSZL1xclvHcsV2dMiminf19x">YouTube playlist from Jim Bethancourt</a></li></ul>
				</ul>
				</section>
				<section>
				<h2>Try it out</h2>
				<p>https://github.com/DebbieRoycroft/Java8Functional<p>
				<ul>
				<li class="fragment fade-in">filesearch</li>
				<li class="fragment fade-in">taskList</li>
				<li class="fragment fade-in">loveLetter</li>
				<li class="fragment fade-in">strategy</li>
				</ul>
				</section
 			</div>

		</div>

		<script src="reveal.js/lib/js/head.min.js"></script>
		<script src="reveal.js/js/reveal.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
				fragments: true,
				embedded: false,
				transition: 'fade', // none/fade/slide/convex/concave/zoom
				transitionSpeed: 'default', // default/fast/slow
				backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom
				viewDistance: 3,

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
